{-# LANGUAGE TypeOperators, TypeSynonymInstances #-}
module Data.Record.Label.Monadic
(
-- * Failure-handling monadic operations.
  getML, setML, modML
, liftML 

-- * State and Reader Monad lens operations.
, getsL, putsL, modifiesL, (=:) 
, asksL, localL
-- ** Deprecated names for compatibility
, getM, setM, modM
, askM, localM
)
where

-- Brandon Simmons, 1/12/2011:
--- NOTES ON STATE/READER FUNCTION NAME CHANGES:
--        getsL, putsL, modifiesL, (=:) 
--      , asksL, localL
--
-- These names are better IMHO because:
--    1) the 'M' at the end of a function usually implies polymorphism 
--        over the Monad class not MonadState
--
--    2) In the same way that (:->) is meant to resemble (->) we can have
--        State monad functions share similar names:
--            getsL              <--->    gets 
--            :: (s :-> a) -> m a         :: (s -> a) -> m a
--
--            asksL              <--->    asks
--            :: (r :-> a) -> m a         :: (r -> a) -> m a
--        
--       Furthermore, the proposed name "putsL" mirrors what would be the
--       "put" equivalent of "gets". Only that function doesn't exist in 
--       the standard libraries (because it can't be easily defined without
--       something like 'fclabels'. Likewise for "modifiesL".
--
--    3) I would love to use the 'M' suffix for the functions that rely on 
--        the new MaybePoint constructor, and will have polymorphic Monad
--        return types.
--


import Control.Monad.State
import Control.Monad.Reader
import Data.Record.Label.Core
import Control.Monad (ap,join)



-- | Get a value out of state pointed to by the specified lens.

getsL :: MonadState s m => (s :-> b) -> m b
getsL = join . gets . getML

-- | Set a value somewhere in state pointed to by the specified lens.

putsL :: MonadState s m => (s :-> b) -> b -> m ()
putsL l = modifiesL l . const

-- | Alias for `putsL' that reads like an assignment.

infixr 7 =:
(=:) :: MonadState s m => (s :-> b) -> b -> m ()
(=:) = putsL

-- | Modify a value with a function somewhere in state pointed to by the
-- specified lens.

modifiesL :: MonadState s m => (s :-> b) -> (b -> b) -> m ()
modifiesL l f = get >>= modML l f >>= put

-- | Fetch a value pointed to by a lens out of a reader environment.

asksL :: MonadReader r m => (r :-> b) -> m b
asksL = join . asks . getML

-- | Execute a computation in a modified environment. The lens is used to
-- point out the part to modify.

localL :: MonadReader r m => (r :-> b) -> (b -> b) -> m a -> m a
localL l f m = ask >>= modML l f >>= \r-> local (const r) m  
 
 
 ------------ OLD NAMES FOR BACKWORDS COMPATIBILITY? ----------

-- | DEPRECATED. use `getsL`.

getM :: MonadState s m => s :-> b -> m b
getM = getsL

-- | DEPRECATED. use `putsL`.

setM :: MonadState s m => s :-> b -> b -> m ()
setM = putsL

-- | DEPRECATED. use `modifiesL`.

modM :: MonadState s m => s :-> b -> (b -> b) -> m ()
modM = modifiesL

-- | DEPRECATED. use `asksL`.

askM :: MonadReader r m => (r :-> b) -> m b
askM = asksL

-- | DEPRECATED. use `localL`.

localM :: MonadReader r m => (r :-> b) -> (b -> b) -> m a -> m a
localM = localL


 ------------ FAILURE-HANDLING MONADIC FUNCTIONS --------------
--
--   These functions can be used to catch errors such as occur when using
--   a lens on the wrong constructor of a multi-constructor type. Currently 
--   we return results in polymorphic Monad class, rather than just Maybe,
--   because:
--
--       1) it is more general and possibly useful
--       2) it mirrors the liftML function (sister to fmapL but supporting 
--           our failure-handling functions) 
--
--   If passed a lens that was generated by `mkLabels` these functions will 
--   never result in a runtime error:


-- | Get a monadic getter function from a lens. If a lens function fails 
-- we call the monad 'fail' method. 

getML :: (Monad m)=> (f :-> a) -> f -> m a
getML = fmap _liftMaybe . _getSafe . _toMaybePoint . unLens


-- | Get a monadic setter function from a lens. If a lens function fails 
-- we call the monad 'fail' method. 

setML :: (Monad m)=> (f :-> a) -> a -> f -> m f
setML = (\s a-> _liftMaybe . s a) . _setSafe . _toMaybePoint . unLens


-- | Get a modifier function from a lens that returns its value in a monad.
-- If a lens function fails we call the monad 'fail' method.

modML :: (Monad m)=> (f :-> a) -> (a -> a) -> f -> m f
modML l m = _liftMaybe . _maybeMod (unLens l) (return . m)


-- | Lift a lens into the Monad class. Any failures raised by lenses using the
-- MaybePoint constructor will call the monad's 'fail' method.

liftML :: Monad m => (a :-> b) -> m a :-> m b
liftML l = let (MaybePoint g s) = _toMaybePoint (unLens l)
               gM mf = _liftMaybe . g =<< mf
               sM mi mf = _liftMaybe =<< (return s `ap` mi `ap` mf)
            in Lens $ Point gM sM


